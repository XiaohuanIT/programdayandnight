##  TreeMap 红黑树

```
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, java.io.Serializable

```

### SortedMap规定了元素可以按key的大小来遍历,它定义了一些返回部分map的方法。

### NavigableMap是对SortedMap的增强,定义了一些返回离目标key最近的元素的方法。
    

## 红黑树特征

定义：含有红黑节点并能自平衡的二叉查找树；

性质1：每个节点或者是黑色,或者是红色

性质2：根节点是黑色

性质3：每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点!）

性质4：如果一个节点是红色的，则它的子节点必须是黑色的;

性质5：任意一个节点到任意一个叶子节点的所有路径上包含相同数目的黑色节点(这里指到叶子节点的路径)

### 红黑树的平衡性



## get

```
public V get(Object key) {
    // 根据key查找元素
    Entry<K,V> p = getEntry(key);
        //找到返回值,否则返回null
        return (p==null ? null : p.value);
    }
  

//有自定义比较器使用自定义比较器，否则使用key实现的比较器接口  
final Entry<K,V> getEntry(Object key) {
        //如果比较器不为空,则使用该比较器遍历树结构来获取指定节点
        if (comparator != null){
            return getEntryUsingComparator(key);
        }
        if (key == null){
            throw new NullPointerException();
        }
        //否则获取key实现的Comparable接口
        @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;
        Entry<K,V> p = root;
        //从root节点开始遍历找到指定节点
        while (p != null) {
            int cmp = k.compareTo(p.key);//比根节点小，左子树遍历
            if (cmp < 0)
                // 如果小于0从左子树查找
                p = p.left;
            else if (cmp > 0)//比根节点大，右子树遍历
                p = p.right;
            else
                return p;
        }
        return null;
    }
   
//使用自定义比较器
final Entry<K,V> getEntryUsingComparator(Object key) {
        @SuppressWarnings("unchecked")
            K k = (K) key;
        Comparator<? super K> cpr = comparator;
        if (cpr != null) {
            Entry<K,V> p = root;
            while (p != null) {
                int cmp = cpr.compare(k, p.key);
                if (cmp < 0)
                    p = p.left;
                else if (cmp > 0)
                    p = p.right;
                else
                    return p;
            }
        }
        return null;
    }
```

---

### 左旋

1. 旋转节点的圆心一定是它的子节点

2. 旋转节点围绕圆心逆时针方向转动

3. 基于最短路径来确定方向旋转【判断左选还是右旋】

![JJvsC4.png](https://s1.ax1x.com/2020/04/21/JJvsC4.png)
```
//以p为支点进行左旋，假设p为图中的x
private void rotateLeft(Entry<K,V> p) {
        if (p != null) {
            //p的右节点,即y
            Entry<K,V> r = p.right; 
            //将y的左节点设置为x的右节点           
            p.right = r.left;
            if (r.left != null){
                //x设置为y的左节点的父节点（如果y的左节点存在的话）
                r.left.parent = p;
            }  
            //设置x的父节点为y的父节点  
            r.parent = p.parent;            
            if (p.parent == null){
                root = r;//如果x的父节点为空，则将y设置为根节点
            }
            //如果x是它父亲节点的左节点，则将y设置为x父节点的左节点
            else if (p.parent.left == p){
                p.parent.left = r;
            }
            else{
                //如果x是它父亲节点的右节点,则将y设置为x父节点的右节点
                p.parent.right = r;
            }
            //将x设置为y的左节点
            r.left = p;
            //将x的父节点设置为y
            p.parent = r;
        }
    }

```

### 右旋

![JYSjVx.png](https://s1.ax1x.com/2020/04/21/JYSjVx.png)


```
// 以p为支点进行右旋，假设p为图中的y
private void rotateRight(Entry<K,V> p) {
        if (p != null) {
            //p的左节点，即x
            Entry<K,V> l = p.left;
            //将y设置为x的右节点的父节点
            p.left = l.right;
            if (l.right != null) {
              //将y设置为x的右节点的父节点
              l.right.parent = p;
            }
            //将y的父亲节点设置为x的父节点
            l.parent = p.parent;
            if (p.parent == null){
                //如果y的父节点是空节点，则将x设置为根节点
                root = l;
            }
            //如果y是它父亲节点的右节点，则将x设置为y的父节点的右节点
            else if (p.parent.right == p){
                //如果y是它父节点的右节点，则将x设为y的父节点的右节点
                p.parent.right = l;
            }
            else {
               //如果y是它父亲节点的左节点，则将x设为y的父亲节点的左节点
               p.parent.left = l;
            }
            //将y设为x的右节点
            l.right = p;
            //将y的父节点设为x
            p.parent = l;
        }
    }

```

## add()

c = currentNode;

1. c = root

2. c.parent = black

3. c.parent = red & c.uncle = red

4. c.parent = red & (c.uncle = black or c.uncle is nil)


[![JGBcYn.png](https://s1.ax1x.com/2020/04/21/JGBcYn.png)](https://imgchr.com/i/JGBcYn)

```
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

```






















































