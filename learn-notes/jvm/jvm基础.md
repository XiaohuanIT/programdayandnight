
## JVM

### Path,ClassPath,JAVA_HOME

#### JAVA_HOME

- 方便引用，配置path时，就是通过引用JAVA_HOME路径来实现的，这样避免了写很长一串的路径（比如在我的电脑中，path原路径是”C:\Program Files\Java\jdk1.8.0_131\bin”，通过指定JAVA_HOME，现在设定的path路径变成了”%JAVA_HOME%\bin”，更加简洁）

- 更加安全，当JDK改变时，仅需要改变JAVA_HOME的路径即可，path和CLASSPATH由于引用了JAVA_HOME，其所对应的路径也会更改。如果不引用JAVA_HOME，则JDK路径改变时，需要手动去设定PATH和CLASSPATH的路径，一旦路径错误，则程序会崩溃。

- 第三方软件（如tomcat，eclipse）都是引用约定好的JAVA_HOME变量，如果不指定JAVA_HOME，则将无法使用第三方软件。

#### Path

- 配置Path是为了在任意目录下都能使用java、javac命令。

#### ClassPath

- 配置CLASSPATH是为了引入一些已经写好的类。

我们一般这样设置：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;

前面的“.”不可少，它代表了我们为自己的java类建立的工作路径，其它的是jdk自带的标准类库路径。

### java指令编译运行以及反汇编

- 反编译：将 .class 文件逆向成 java源代码

- 反汇编：根据编译后的结果，倒推源码编译的过程，这里就可以看出代码逻辑真实编译、执行过程的每一步，对于性能优化、问题追溯等具有十分强大的帮助

- javac;//编译

```
cd /Users/nivellefu/IdeaProjects/javadaybyday/java-base/src/main/java/com/nivelle/base/pojo/javaclass;javac -d . /Users/nivellefu/IdeaProjects/javadaybyday/java-base/src/main/java/com/nivelle/base/pojo/javaclass/JvmExceptionDemo.java
```
- java;//运行

```
java class文件指定的page路径+类名

```

- javap //根据classs字节码文件，反解析出当前类对应的code区（汇编指令），本地变量表，异常表和代码偏移量映射表，常量池等信息。


```
javap com.nivelle.base.pojo.javaclass/JvmExceptionDemo


Compiled from "JvmExceptionDemo.java"
public class com.nivelle.base.pojo.javaclass.JvmExceptionDemo {
  public com.nivelle.base.pojo.javaclass.JvmExceptionDemo();
  public void test();
  public static void main(java.lang.String[]);
}

 
```

### 数据类型

- 基本类型

- 引用类型: 类、接口、数组类和泛型参数,泛型参数会在编译过程中被擦除; 数组类是由 Java 虚拟机直接生成

- boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1,而“false”被映射为整数 0;

### java基本类型的大小

1. 在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。

2. boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。

3. 作为局部变量,在 32 位的 HotSpot 中,基本类型在栈上将占用 4 个字节;而在 64 位的 HotSpot 中,他们将占 8 个字节。

4. 这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合


### 类的加载


#### 加载类

加载，是指查找字节流，并且据此创建类的过程

- 启动类加载器：JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）

- 扩展类加载器： JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）

- 应用类加载器： 它负责加载应用程序路径下的类，-cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。

#### 链接

是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程

- 验证

- 准备：被加载类的静态字段分配内存

- 解析：符号引用-》实际引用；编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

  如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）


#### 初始化

**为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。**

- 如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值

- 如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。

  除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 < clinit >。
  
- Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次

**java类的初始化触发**

(1). 当虚拟机启动时，初始化用户指定的主类；

(2). 当遇到用以**新建目标类**实例的 new 指令时，初始化 new 指令的目标类；

(3). 当遇到调用**静态方法**的指令时，初始化该静态方法所在的类;

(4). 当遇到访问**静态字段**的指令时，初始化该静态字段所在的类;

(5). 子类的初始化会触发父类的初始化;

(6). 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化;

(7). 使用反射 API 对某个类进行反射调用时，初始化这个类；

(8). 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

### jvm 方法调用


- 重写: 多态最重要的一种体现方，它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

- 重载: 名字相同,参数类型不同的方法;重载也可以作用于这个类所继承而来的方法；

```
重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；

2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；

3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

```

- Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，
由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

```

在编译完成之后，我们可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。

当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在Java编译器的用户类路径上时，当前版本的Java编译器会直接选取第一个方法名以及参数类型匹配的方法。

并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。

```

- Java 虚拟机的动态绑定是通过**方法表**这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。

- Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。


### Java方法反射调用性能慢的原因

1. 由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组


2. 由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱


**以上两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。**

3. 方法内联:方法内联指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程

### 内联函数就是指函数在被调用的地方直接展开，编译器在调用时不用像一般函数那样，参数压栈，返回时参数出栈以及资源释放等，这样提高了程序执行速度。Java不支持直接声明为内联函数的，如果想让他内联，则是由编译器说了算，你只能够向编译器提出请求。



### jvm java对象

- 对象头: 
 
 1. 标记字段 :java虚拟机有关该对象运行数据，如哈希码，GC信息，锁信息
 
 ```
 在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。以 Integer 类为例，它仅有一个 int 类型的私有字段，占 4 个字节。因此，每一个 Integer 对象的额外内存开销至少是 400%。这也是为什么 Java 要引入基本类型的原因之一。
 ```
 
 2. 类型指针 : 指向该对象的类


   - 压缩指针: 为了减少类型指针的内存占用，将64位指针压缩至32位，进而节约内存。之前64位寻址，寻的是字节。现在32位寻址，寻的是变量。再加上内存对齐(补齐为8的倍数)，可以每次寻变量都以一定的规则寻找，并且一定可以找得到。

   - 内存对齐:
  
     1. 默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充（padding）

     2. 内存对齐的另一个好处是，使得CPU缓存行可以更好的实施。保证每个变量都只出现在一条缓存行中，不会出现跨行缓存。提高程序的执行效率。

   - 字段重排序: 其实就是更好的执行内存对齐标准，会调整字段在内存中的分布，达到方便寻址和节省空间的目的。

   
   - 虚共享:当两个线程分别访问一个对象中的不同volatile字段，理论上是不涉及变量共享和同步要求的。但是如果两个volatile字段处于同一个CPU缓存行中，对其中一个volatile字段的写操作，会导致整个缓存行的写回和读取操作，进而影响到了另一个volatile变量，也就是实际上的共享问题
   
     - @Contented注解:该注解就是用来解决虚共享问题的，被该注解标识的变量，会独占一个CPU缓存行。但也因此浪费了大量的内存空间。


### jvm垃圾回收

#### 引用计数法：额外的空间来存储计数器，解决不了循环引用，造成内存泄露

#### 可达性分析：将GCRoots作为初始的存活对象合集，然后从该合集出发，探索所有能够被该集合引用到的兑现，并将其加入到该集合。常见GCRoot如下：

- java方法栈桢中的局部变量

- 已加载类的静态变量

- JNI handles

- 已启动且未停止的java线程

**缺点**: 多线程环境下其他线程更新已经访问过的对象中的引用，从而造成误报(将引用设置为null)或者漏报(将引用设置为未被访问过的对象)。

### stop-the-world 解决漏报问题

- 停止其他非垃圾回收线程，直到完成垃圾回收，但造成了GC pause

- safepoint:当收到stop-the-world请求，它会等待所有的线程达到安全点，才允许请求stop-the-world的线程进行独占工作。（安全点：找到一个稳定的执行状态，在合格状态下java虚拟机的堆栈不会发生变化）




















