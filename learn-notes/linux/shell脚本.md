#### 管道符号

- "｜" :将前一个命令执行结果传递给后面的命令

#### 重定向符号

- 输入重定向 "<"

````

read var < /path/to/a/file

echo $var 则显示/path/to/a/file文件的内容

````

- 输出重定向 ">(覆盖)",">>(追加)","2>(收集错误)"","&>（全部重定向到指定文件,不管错误与正确）"

#### 变量

- let 

```
let a=10+20 //等号左右不要有空格

```
- cmd1=$(ls /root);//将命令执行的结果直接赋值给cmd1,还可以使用"" 代替$()


#### $

- $? //上一条命令是否执行成功 成功:0 失败:1

- $$ //显示当前进程pid

- $0 //当前执行的程序

#### 数组

- 名称=（a，b,c）;//赋值

- $(数组变量名[@]);//显示数组所有元素

- $(数组变量名 #[@]);//显示数组所有元素个数

- $(数组变量名[0]);//显示数组第0个元素


#### 特殊符号转义和引用

- ; //分割命令

- \ ;//转义 (作为普通自符输出，而不是其特殊意义)

- "" //不完全引用，变量进行解释(eg : echo aaa bbb \"\"; aaa bbb "")(echo "$var1";123)

- '' //完全引用 ,是什么就显示什么//var1 =123; echo '$var1';$var1

- `` //反引号,要执行的命令

#### 赋值运算

- = //算术赋值和字符串赋值

- unset //取消变量赋值

- +，-，*，/，**，%

- expr ;//使用expr进行运算，只支持整数

- let "变量名"= 变量值；变量值以0开头为八进制，以0x开头为十六进制

- ((a=10));echo $((10+20));((a++))//双圆括号是let命令的简写

#### 脚本的两种运行方式

- 可执行文件

```
1. chmod +x ./test.sh  #使脚本具有执行权限

2. 一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。

```

- 作为解释器参数

这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名

#### 执行 shFile脚本

- bash ./shFile //可以不用执行权限，对当前目录不产生影响，子进程内建命令

- ./shFile //需要执行权限；对当前目录产生影响，不产生子进程

- source ./shFile //对当前目录产生影响，不产生子进程

- . shFile //对当前目录产生影响，不产生子进程

